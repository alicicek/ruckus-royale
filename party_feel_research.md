# Party Brawler Feel Research

Research compiled 2026-02-23 for Ruckus Royale web party brawler.
Updated with animation + ragdoll blending deep-dive.

## Baseline Findings

### Current Architecture
- **Server**: Colyseus v0.16.5 authoritative simulation at 60Hz, snapshots at 20Hz
- **Client**: Three.js v0.179.1 + Rapier v0.17.3 + Colyseus.js v0.16.8
- **Shared**: Deterministic `integrateMotion()` used by both client (prediction) and server (authoritative)

### Current Movement Model
- **Velocity-based with exponential drag**: `v += (targetV - v) * clamp(drag * dt, 0, 1)`
- No real physics bodies for players -- just Vector3 position/velocity math
- Rapier used CLIENT-ONLY for active ragdoll skeleton (10 bodies per character)
- Ground drag: 10, Air drag: 1.8, Gravity: -28, Jump: 10, Move speed: 7

### Current Ragdoll System (ragdoll.ts)
- 10-body ragdoll skeleton: torso (kinematic root), head, 2 upper arms, 2 forearms, 2 thighs, 2 shins
- Spherical joints (shoulders, hips, neck) with force-based guidance (impulses toward target positions)
- Revolute joints (elbows, knees) with PD motor targets (`configureMotorPosition`)
- Per-limb stiffness with graduated recovery (torso first, arms last)
- Hit reaction, knockout, and recovery state machine
- Grab joints (spring between hand and target torso) and throw impulses
- Collision groups per ragdoll (limbs collide with other ragdolls but not their own)

### Current Combat
- Range + alignment check, instant impulse + stun accumulation
- Grab creates spring joint between hand and target torso with break force
- Knockout at stun >= 100, stun decays at 4/s
- Hit impulses applied to struck body part with per-limb stiffness drop
- Ragdoll knockout: stiffness -> 0, recovery timer, graduated limb recovery

### Current Rendering
- Procedural capsule + sphere + cylinder geometry (no skinned mesh)
- 10 body-part meshes positioned by ragdoll bone transforms each frame
- Visual scale multiplier (1.4x) for chunky look vs physics colliders

### Key Gap: No Animations
| Feature | Current | Target |
|---------|---------|--------|
| Walk cycle | `Math.sin(timeSec * 8)` on elbows/knees | Proper procedural or keyframed walk cycle |
| Idle pose | Arms hang, knees slightly bent | Breathing, weight shift, head bob |
| Attack animation | No animation, just impulse event | Wind-up, strike, follow-through pose sequence |
| Grab animation | No animation, spring joint only | Arms reach forward, hands clamp, drag pose |
| Visual body | Primitive capsule/sphere shapes | Skinned mesh or better-shaped primitives |
| Animation system | None | PoseProvider -> motor targets pipeline |

---

## 1. Party Animals: Animation System Breakdown

### How Recreate Games Does It

Party Animals (Recreate Games, Unity) uses **full dynamics-driven animation** rather than traditional animation state machines. They built a **custom in-house physics engine** specifically for ragdoll character interaction.

**Architecture:**
- Characters are entirely physics-driven. There are no traditional animation state machines controlling movement.
- All movement is **procedural** -- limb positions are computed by the physics system each frame, not read from keyframe data.
- The "animation" is generated by **motor targets** that physics joints try to reach.
- When a character walks, physics motors drive the legs through a walk-like cycle, but actual limb positions are determined by physics simulation.

**What Makes Characters Feel "Alive":**
1. **Soft bodies / deformable characters** -- characters squish and deform slightly on impact.
2. **Carefully tuned PD gains per joint** -- shoulders are loose (floppy arms), hips are stiff (stable walking), elbows are medium (natural arm swing).
3. **Layered reaction system** -- light hits cause local wobble (one arm), heavy hits cause full-body stumble, knockouts cause total ragdoll collapse.
4. **Physics-based audio** -- sounds driven by collision forces, not animation events.

**Critical takeaway:** Party Animals does NOT blend keyframe animations with ragdoll in the traditional sense. They use **procedural animation targets** that the physics system tries to match. The "wobbly" feel comes from physics motors never perfectly matching targets, creating constant organic micro-movements.

**Source:**
- [Party Animals (Grokipedia)](https://grokipedia.com/page/Party_Animals_(video_game))
- [Physics-Based Character Animation (Ray Liao, Medium)](https://boruiliao.medium.com/what-is-physics-based-character-animation-in-games-using-unreal-engine-approach-as-an-example-571560376e4c)

---

## 2. Gang Beasts: Force-Based Locomotion

### Why It Feels Responsive Despite Being Physics-Driven

Gang Beasts (Boneloaf, Unity with PhysX 3.3) achieves responsive controls through **"intention-based" physics:**

**The Secret Sauce:**
1. **Input maps directly to force application, not animation triggers.** Press "move right" -> force is immediately applied. No animation startup delay.
2. **The character body responds to forces instantly** -- physics processes the force on the next step (50-60Hz). The visual result may be wobbly, but the character IS moving in the intended direction immediately.
3. **High force multipliers on movement inputs** -- forces are deliberately strong enough to overcome character's weight and drag, ensuring visible acceleration within 1-2 frames.
4. **Deliberate drag and damping** -- characters have high linear damping that makes them stop quickly when input stops, giving responsive "arcade" feel despite the physics system.

**PhysX 3.3 Migration Impact:**
The move to PhysX 3.3 was a significant reworking. The new engine was "much more exact" than previous versions. Early versions used "a high number of forces" acting on character models.

**Architecture:**
- Root body: kinematic or high-mass dynamic body receiving movement forces
- Limbs: dynamic bodies connected via joints with configurable angular drives
- Each joint has a target rotation set procedurally based on character state
- Grabbing: temporary joints between characters
- Knockout: all joint motor forces removed -> collapse

**Why the Wobble Works:**
As Human Fall Flat's developer noted: "Gang Beasts and Octodad were the triggers, showing that you can make a fully active ragdoll in 3D, not just use them for the death animation in FPS." The deliberate awkwardness creates unpredictable, humorous situations. This is a design choice: "victory depends less on quick reflexes and more on understanding how to manipulate the game's physics."

**Source:**
- [Gang Beasts Physics (Unity Forums)](https://discussions.unity.com/t/how-to-create-physics-based-animation-character-like-in-gang-beasts/230757)
- [Gang Beasts/Human Fall Flat (Unity Forums)](https://discussions.unity.com/t/making-gang-beasts-human-fall-flat-like-characters/723911)
- [Gang Beasts/HFF in UE4 (Epic Forums)](https://forums.unrealengine.com/t/gang-beasts-human-fall-flat-ragdoll-characters-in-ue4/155641)

---

## 3. Active Ragdoll with Animation Blending: The Two-Skeleton Architecture

### Industry Standard Approach

This is the most established technique used in AAA games (Euphoria engine in GTA/Red Dead, Killing Floor 2, etc.).

**How It Works:**

```
[Animation Skeleton]  <--  Invisible, plays normal keyframe animations
        |
        | (target pose per bone)
        v
[Physics Skeleton]    <--  Visible, ragdoll with PD-controlled joints
        |
        | (physics-resolved poses)
        v
[Visual Mesh]         <--  Rendered on screen
```

**Step by step:**
1. An **invisible animation skeleton** plays standard keyframe animations (walk cycle, punch, idle). This skeleton ignores physics entirely.
2. Each frame, the animation skeleton's bone rotations become **motor targets** for the corresponding physics skeleton joints.
3. The **visible physics skeleton** uses PD-controlled joint motors that try to match the animation targets but are affected by external forces.
4. The visual mesh reads its bone transforms from the physics skeleton.

**The Alpha/Stiffness Parameter (Hairibar.Ragdoll):**
A per-bone "alpha" value (0 to 1) controls how strongly physics follows the animation:
- `alpha = 1.0`: Physics reaches target pose in one physics step (pure animation)
- `alpha = 0.5`: Takes two steps, some deformation under force (active ragdoll)
- `alpha = 0.0`: Pure ragdoll, no animation influence (knockout)

This maps exactly to our existing `stiffnessScale` and `limbStiffness` system.

**Position vs Rotation Matching:**
- **Position matching**: world-space, ensures ragdoll bones align with animated counterparts' locations
- **Rotation matching**: local-space per bone, allows ragdoll to attempt target poses while deforming under forces
- Both operate independently and can be configured separately

**Damping Ratio (0-1):** Manages spring oscillation.
- `1.0`: No oscillations (critical damping)
- `< 1.0`: Progressively more "wobble" (secondary motion without explicit animation)

**Spring-Damper Torque Formula:**
```
torque = Kp * (targetRotation - currentRotation) - Kd * angularVelocity
```

Where:
- `Kp` (proportional gain / stiffness) = how strongly the joint tries to reach target
- `Kd` (derivative gain / damping) = how much the joint resists oscillation
- `targetRotation` = rotation from the animation skeleton
- `currentRotation` = current physics joint rotation

**Source:**
- [Animation of Active Ragdolls (Jan Schneider, Medium)](https://medium.com/@jacasch/animation-of-active-ragdolls-in-games-32ca9d98afc9)
- [How to Make Active Ragdolls (Sergio Abreu, Medium)](https://sergioabreu-g.medium.com/how-to-make-active-ragdolls-in-unity-35347dcb952d)
- [Hairibar.Ragdoll (GitHub)](https://github.com/hairibar/Hairibar.Ragdoll)
- [ActiveRagdoll PID (GitHub)](https://github.com/ashleve/ActiveRagdoll)
- [Erin Catto GDC Ragdolls PDF](https://box2d.org/files/ErinCatto_Ragdolls_GDC2012.pdf)
- [Joint-Torque Control Paper (xbdev.net)](https://www.xbdev.net/misc_demos/demos/joints_torques_and_control/paper.pdf)

---

## 4. Rapier.js Motor API for Animation-Driven Ragdoll

### Joint Motor API (Our Physics Engine)

Rapier.js provides PD-controller based motors on supported joints:

**Configuration Methods:**
```typescript
// Position control (spring toward target position)
joint.configureMotorPosition(targetPos, stiffness, damping);

// Velocity control (maintain target velocity)
joint.configureMotorVelocity(targetVel, damping);

// Full manual control (both position and velocity targets)
joint.configureMotor(targetPos, targetVel, stiffness, damping);

// Motor model selection
joint.configureMotorModel(RAPIER.MotorModel.ForceBased);
// ForceBased = accounts for mass, AccelerationBased = ignores mass
```

**Internal Spring Equation:**
```
impulse = stiffness * (targetPos - currentPos) + damping * (targetVel - currentVel)
```

**Supported Joint Types with Motors:**
- **Revolute joints** (elbows, knees): Full motor support. We already use these.
- **Prismatic joints** (translational): Full motor support.
- **Spherical joints** (shoulders, hips): **Motor support incomplete in JS bindings.** See [Issue #287](https://github.com/dimforge/rapier.js/issues/287).

### The Spherical Joint Motor Problem

For shoulders and hips, we need 3-DOF rotation control. Rapier's spherical joint motor support was temporarily removed during alpha. **Current workarounds:**

1. **Force-based guidance** (what we currently do): Apply PD-like impulses to limb bodies. Works but less stable than true joint motors.
2. **Three revolute joints in series**: Chain three single-axis joints for per-axis motor control. Complex but precise.
3. **Generic joint with per-axis motors**: Rapier's `GenericJoint` may support motor configuration on individual axes.

### Integration Pipeline with Three.js Animation

```
Three.js AnimationMixer  -->  Bone.quaternion  -->  Rapier Joint Motor Target
       (invisible)                                      (physics skeleton)
                                                              |
                                                              v
                                                    Rapier Physics Step
                                                              |
                                                              v
                                                  RigidBody.rotation()  -->  Visible Mesh
```

```typescript
// Load animated GLTF model (future Option B)
const gltf = await new GLTFLoader().loadAsync('character.glb');
const mixer = new THREE.AnimationMixer(gltf.scene);
const walkAction = mixer.clipAction(gltf.animations.find(a => a.name === 'walk'));
walkAction.play();

// Each frame:
mixer.update(dt);
const targetQuat = bone.quaternion.clone(); // from animation
// Convert to Rapier joint motor target...
joint.configureMotorPosition(targetAngle, stiffness * limbScale, damping * limbScale);
```

**Source:**
- [Rapier.js Joints Documentation](https://rapier.rs/docs/user_guides/javascript/joints/)
- [Rapier ImpulseJoint Motors (sbcode.net)](https://sbcode.net/threejs/physics-rapier-impulsejoint-motors/)
- [RapierJS Ragdoll Physics (Three.js Resources)](https://threejsresources.com/tool/rapierjs-ragdoll-physics)
- [Rapier Spherical Joint Motor Issue #287](https://github.com/dimforge/rapier.js/issues/287)

---

## 5. Open Source Implementations

### Web-Based (Three.js / Babylon.js)

| Project | Engine | Physics | Animation Blending? | Notes |
|---------|--------|---------|---------------------|-------|
| [RapierJS Ragdoll Physics](https://threejsresources.com/tool/rapierjs-ragdoll-physics) | Three.js | Rapier | Partial | Syncs GLTF bones to physics bodies, live demo |
| [ragdoll.js](https://github.com/jongomez/ragdoll.js) | Babylon.js | Oimo/Ammo/Cannon | No | Small ragdoll creation library |
| [Cannon.js Ragdoll](https://github.com/schteppe/cannon.js/blob/master/demos/ragdoll.html) | Three.js | Cannon.js | No | Classic ragdoll demo |
| [Ammo.js Ragdoll](http://schteppe.github.io/ammo.js-demos/demos/RagdollDemo/three.html) | Three.js | Ammo.js | No | Cone-twist constraints |
| [three-game-engine](https://github.com/WesUnwin/three-game-engine) | Three.js | Rapier | Partial | Game engine with physics + animation |
| [ecctrl](https://github.com/pmndrs/ecctrl) | R3F | Rapier | Yes | Character controller with walk/run/attack animations |
| [demo-rapier-three](https://github.com/viridia/demo-rapier-three) | Three.js | Rapier | No | Clean Rapier+Three.js integration |
| [react-three-rapier](https://github.com/pmndrs/react-three-rapier) | R3F | Rapier | Partial | Community physics integration |
| [Creature WebGL](https://github.com/kestrelm/Creature_WebGL) | Multi | N/A | Yes | 2D skeletal animation runtimes |

### Game Engine References

| Project | Engine | Key Technique |
|---------|--------|---------------|
| [Hairibar.Ragdoll](https://github.com/hairibar/Hairibar.Ragdoll) | Unity | Best-documented two-skeleton approach. Alpha/damping per bone. |
| [active-ragdolls](https://github.com/sergioabreu-g/active-ragdolls) | Unity | Clean active ragdoll with ConfigurableJoints |
| [ActiveRagdoll PID](https://github.com/ashleve/ActiveRagdoll) | Unity | From-scratch PID controller, master/slave architecture |
| [Active Ragdolls (Godot)](https://www.gadgetgodot.com/u/r3xg1l/active-rigid-body-ragdolls) | Godot | Active rigid body ragdolls |

### Babylon.js Ragdoll API (Most Mature Web Reference)

Babylon.js has the most complete web-based ragdoll system with animation blending:

```javascript
// Create ragdoll from skeleton
const ragdoll = new BABYLON.Ragdoll(skeleton, mesh, config);

// Kinematic mode (default): animation drives physics
// Bones interact with physics but animation controls position

// Dynamic mode: physics takes over (full ragdoll)
ragdoll.ragdoll();

// Per-bone physics access
ragdoll.getAggregate(0)?.body.applyImpulse(impulse);
```

The two modes map to our system:
- **Kinematic** = our `stiffnessScale = 1` (animation drives)
- **Dynamic** = our `stiffnessScale = 0` (physics drives / knockout)
- **Blending** = our variable `stiffnessScale` (active ragdoll / hit reaction)

**Source:**
- [Babylon.js Ragdoll Docs](https://doc.babylonjs.com/features/featuresDeepDive/physics/ragdolls)

---

## 6. Recommended Implementation Path

### Option A: Procedural Animation Targets (Party Animals Style) -- RECOMMENDED FOR NOW

Enhance our existing system without requiring 3D models or animation files. Matches the Party Animals/Gang Beasts philosophy.

**What to build:**
1. **`PoseProvider` interface** -- abstract target pose generation from physics application
2. **Procedural walk cycle** -- proper biomechanical walk function, not just `sin(time)`
3. **Procedural attack poses** -- keyframe sequences for light punch, heavy swing
4. **Procedural grab poses** -- arms reach forward, hands clamp
5. **Procedural idle poses** -- breathing motion, weight shifting, head bob
6. **Pose blending system** -- lerp between poses based on game state

**Pros:**
- No 3D models or animation files needed
- Works with existing primitive-shape rendering
- Can be implemented incrementally
- Lightweight
- Perfect for "chunky party brawler" aesthetic

**Estimated effort:** 1-2 weeks for solid procedural animations

### Option B: Two-Skeleton Blending (Industry Standard) -- FUTURE

Full animation-physics blending with authored character models.

**What to build:**
1. 3D character model in Blender with skeleton matching our ragdoll bones
2. Animation clips for all actions
3. Three.js AnimationMixer on invisible skeleton
4. Bone-to-motor bridge (read animation rotations, set as Rapier motor targets)
5. SkinnedMesh rendering replacing primitives

**Estimated effort:** 3-5 weeks including modeling

### Option C: Hybrid (PRAGMATIC) -- RECOMMENDED ARCHITECTURE

Start with Option A, design the system so Option B can be plugged in later.

```typescript
interface PoseProvider {
  computePose(state: {
    isMoving: boolean;
    speed: number;
    facingYaw: number;
    isAttacking: boolean;
    attackType: 'light' | 'heavy';
    attackPhase: number;  // 0-1
    isGrabbing: boolean;
    isStunned: boolean;
    timeSec: number;
  }): Map<BoneName, { qx: number; qy: number; qz: number; qw: number }>;
}

// Phase 1: Procedural poses
class ProceduralPoseProvider implements PoseProvider { ... }

// Phase 2 (future): Animation-driven poses
class AnimationPoseProvider implements PoseProvider {
  constructor(private mixer: THREE.AnimationMixer) { ... }
}
```

---

## 7. Technical Implementation Details

### Procedural Walk Cycle (Immediate Priority)

A proper walk cycle needs these components:

```
Walk Phase (0 to 2*PI, advancing with speed):
  phase += speed * dt * CADENCE_FACTOR

Left Leg:
  hip_pitch  = sin(phase) * STRIDE_AMPLITUDE
  knee_bend  = max(0, -cos(phase)) * KNEE_AMPLITUDE + KNEE_OFFSET

Right Leg (opposite phase):
  hip_pitch  = sin(phase + PI) * STRIDE_AMPLITUDE
  knee_bend  = max(0, -cos(phase + PI)) * KNEE_AMPLITUDE + KNEE_OFFSET

Left Arm (opposite to left leg for natural gait):
  shoulder_pitch = sin(phase + PI) * ARM_SWING_AMPLITUDE
  elbow_bend     = ARM_BASELINE + sin(phase + PI) * ARM_SWING_SECONDARY

Right Arm:
  shoulder_pitch = sin(phase) * ARM_SWING_AMPLITUDE
  elbow_bend     = ARM_BASELINE + sin(phase) * ARM_SWING_SECONDARY

Torso:
  lateral_lean   = sin(phase * 2) * LEAN_AMPLITUDE  (double freq for left-right sway)
  forward_lean   = speed * LEAN_FACTOR

Head:
  counter_rotate to torso lean (gaze stabilization)
```

### Attack Pose Keyframe Sequences

```typescript
const LIGHT_PUNCH_FRAMES = [
  { t: 0.00, r_shoulder_pitch: 0, r_elbow: 0.2 },      // Idle
  { t: 0.08, r_shoulder_pitch: -0.5, r_elbow: 1.5 },    // Wind-up (arm pulls back)
  { t: 0.15, r_shoulder_pitch: 1.2, r_elbow: 0.1 },     // Strike (arm extends)
  { t: 0.30, r_shoulder_pitch: 0.3, r_elbow: 0.4 },     // Follow-through
  { t: 0.45, r_shoulder_pitch: 0, r_elbow: 0.2 },       // Return to idle
];

const HEAVY_SWING_FRAMES = [
  { t: 0.00, r_shoulder_pitch: 0, r_shoulder_yaw: 0 },
  { t: 0.20, r_shoulder_pitch: -1.2, torso_twist: -0.4 }, // Big wind-up
  { t: 0.35, r_shoulder_pitch: 1.8, torso_twist: 0.6 },   // Full swing
  { t: 0.60, r_shoulder_pitch: 0.4, torso_twist: 0.1 },   // Follow-through
  { t: 0.95, r_shoulder_pitch: 0, torso_twist: 0 },        // Return
];
```

### Rapier Motor Target Setting

```typescript
// Revolute joints (elbows, knees) -- direct motor:
const joint = ragdoll.joints.get('l_elbow') as RAPIER.RevoluteImpulseJoint;
const targetAngle = pose.get('l_lower_arm')!;
const scale = ragdoll.limbStiffness.get('l_lower_arm')!;
joint.configureMotorPosition(targetAngle, PD.kp * scale, PD.kd * scale);

// Spherical joints (shoulders, hips) -- force-based workaround:
const targetWorldPos = computeTargetWorldPos(bone, torsoTransform, poseTarget);
const currentPos = body.translation();
const delta = subtract(targetWorldPos, currentPos);
const vel = body.linvel();
body.applyImpulse({
  x: delta.x * kp * scale - vel.x * kd * scale,
  y: delta.y * kp * scale - vel.y * kd * scale,
  z: delta.z * kp * scale - vel.z * kd * scale,
}, true);
```

---

## 8. Summary

**The gap is clear:** Our ragdoll physics system is solid (10 bodies, PD motors, hit reactions, grab joints, knockout/recovery). But our pose targets are too simple -- just `Math.sin(time)`. Characters need proper procedural animations driving those targets to feel alive.

**Recommended immediate actions:**
1. Create a `PoseProvider` interface to decouple pose generation from physics
2. Implement `ProceduralPoseProvider` with biomechanically-correct walk/run cycles
3. Add attack pose sequences triggered by game events
4. Add idle animation (breathing, weight shift) for standing still
5. Add grab pose (arms reach forward)
6. Blend between poses based on game state transitions

**The architecture is right.** We do not need to switch engines. We need better animation targets feeding into the same Rapier PD motor system we already have.

---

## All Sources

### Party Animals & Gang Beasts
- [Party Animals (Grokipedia)](https://grokipedia.com/page/Party_Animals_(video_game))
- [Physics-Based Character Animation (Ray Liao)](https://boruiliao.medium.com/what-is-physics-based-character-animation-in-games-using-unreal-engine-approach-as-an-example-571560376e4c)
- [Gang Beasts Physics (Unity Forums)](https://discussions.unity.com/t/how-to-create-physics-based-animation-character-like-in-gang-beasts/230757)
- [Gang Beasts/HFF Characters (Unity Forums)](https://discussions.unity.com/t/making-gang-beasts-human-fall-flat-like-characters/723911)
- [Gang Beasts in UE4 (Epic Forums)](https://forums.unrealengine.com/t/gang-beasts-human-fall-flat-ragdoll-characters-in-ue4/155641)
- [Ragdoll Physics in Games (Bluebird)](https://bluebirdinternational.com/ragdoll-physics/)

### Active Ragdoll Techniques
- [Animation of Active Ragdolls (Jan Schneider)](https://medium.com/@jacasch/animation-of-active-ragdolls-in-games-32ca9d98afc9)
- [How to Make Active Ragdolls (Sergio Abreu)](https://sergioabreu-g.medium.com/how-to-make-active-ragdolls-in-unity-35347dcb952d)
- [Hairibar.Ragdoll (GitHub)](https://github.com/hairibar/Hairibar.Ragdoll)
- [ActiveRagdoll PID (GitHub)](https://github.com/ashleve/ActiveRagdoll)
- [active-ragdolls (GitHub)](https://github.com/sergioabreu-g/active-ragdolls)
- [Active Ragdolls in Godot](https://www.gadgetgodot.com/u/r3xg1l/active-rigid-body-ragdolls)
- [Erin Catto GDC Ragdolls](https://box2d.org/files/ErinCatto_Ragdolls_GDC2012.pdf)
- [Joint-Torque Control Paper](https://www.xbdev.net/misc_demos/demos/joints_torques_and_control/paper.pdf)
- [Spring Roll Call (theorangeduck)](https://theorangeduck.com/page/spring-roll-call)
- [Blending Keyframe with Physics (Polycount)](https://polycount.com/discussion/229271/blending-keyframe-animation-with-physics-partial-ragdoll)

### Rapier.js & Three.js
- [Rapier.js Joints Documentation](https://rapier.rs/docs/user_guides/javascript/joints/)
- [Rapier ImpulseJoint Motors (sbcode.net)](https://sbcode.net/threejs/physics-rapier-impulsejoint-motors/)
- [RapierJS Ragdoll Physics (Three.js Resources)](https://threejsresources.com/tool/rapierjs-ragdoll-physics)
- [Rapier Spherical Joint Motor Issue #287](https://github.com/dimforge/rapier.js/issues/287)
- [Rapier Character Controller](https://rapier.rs/docs/user_guides/javascript/character_controller/)
- [Three.js Skeletal Animation (DeepWiki)](https://deepwiki.com/mrdoob/three.js/5.2-skeletal-animation-and-skinning)

### Open Source Projects
- [ragdoll.js (GitHub)](https://github.com/jongomez/ragdoll.js)
- [three-game-engine (GitHub)](https://github.com/WesUnwin/three-game-engine)
- [ecctrl (GitHub)](https://github.com/pmndrs/ecctrl)
- [demo-rapier-three (GitHub)](https://github.com/viridia/demo-rapier-three)
- [react-three-rapier (GitHub)](https://github.com/pmndrs/react-three-rapier)
- [Cannon.js Ragdoll Demo](https://github.com/schteppe/cannon.js/blob/master/demos/ragdoll.html)
- [Ammo.js Ragdoll Demo](http://schteppe.github.io/ammo.js-demos/demos/RagdollDemo/three.html)
- [Creature WebGL (GitHub)](https://github.com/kestrelm/Creature_WebGL)
- [threeZboingZboing (GitHub)](https://github.com/WebAR-rocks/threeZboingZboing)

### Babylon.js Reference
- [Babylon.js Ragdoll Docs](https://doc.babylonjs.com/features/featuresDeepDive/physics/ragdolls)
- [Babylon.js Ragdoll Library (Forum)](https://forum.babylonjs.com/t/small-lib-for-creating-ragdolls/14924)
- [Active Ragdoll Physics (Babylon Forum)](https://forum.babylonjs.com/t/active-ragdoll-physics/49526)

### Networking
- [Networked Physics (Gaffer on Games)](https://gafferongames.com/post/introduction_to_networked_physics/)
- [State Synchronization (Gaffer on Games)](https://gafferongames.com/post/state_synchronization/)
- [Client-Side Prediction (Gabriel Gambetta)](https://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html)

### GDC Talks
- [Physics Driven Ragdolls at EA](https://www.gdcvault.com/play/1025210/)
- [Moving Beyond Ragdolls](https://www.gdcvault.com/play/1020276/)
- [Ragdoll Motion Matching](https://www.gdcvault.com/play/1026712/)
